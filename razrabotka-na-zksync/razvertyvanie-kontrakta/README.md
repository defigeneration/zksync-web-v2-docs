# Развертывание контракта



Для соблюдения такого же уровня безопасности, как на L1, оператор zkSync должен публиковать в сети Ethereum исходный код для каждого развернутого контракта. Однако, в случае, если развернуто несколько контрактов с одинаковым исходным кодом, опубликован он будет лишь однажды.

В то время, как развертывание контракта впервые может быть достаточно дорогой операцией, фабрики, разворачивающие контракты с одинаковым исходным кодом могут сохранять значительное количество средств по сравнению с L1.

Все эти специфики развертывания смарт-контрактов на zkEVM согласовываются с главным правилом: _Оператор должен знать код контракта до того, как он (контракт) будет развернут_. Это означает, что развертывание контракта возможно исключительно с использованием транзакции типа `EIP712`, где поле `factory_deps` содержит предоставленный байткод. Больше о транзакциях типа EIP712 [тут](https://v2-docs.zksync.io/api/api.html#eip712).

Итого:

* **Как развертывание смарт-контрактов работает на Ethereum.** Для развертывания контракта пользователь отправляет транзакцию на нулевой адрес (`0x000...000`), в которой поле `data` равняется байткоду контракта конкатенированного(связанного) с параметрами конструктора.
* **Как развертывание смарт-контрактов работает на zkSync.** Для развертывания смарт-контракта пользователь вызывает функцию `create` в [ContractDeployer](../../ponimanie-zksync/sistemnye-kontrakty/#contractdeployer) и предоставляет хэш контракта для публикации вместе с параметрами конструктора. Байткод контракта передается в поле `factory_deps` транзакции типа EIP712. Если контракт - фабрика (т.е. он может разворачивать другие контракты), байткод этих контрактов также должен быть включен в  `factory_deps`.

Плагин [hardhat-zksync-deploy](https://v2-docs.zksync.io/api/hardhat) обеспечивает процесс развертывания. Вот [руководство по его использованию](https://v2-docs.zksync.io/api/hardhat/getting-started.html#prerequisites).

### Поддержка Solidity/Vyper <a href="#solidity-vyper-support" id="solidity-vyper-support"></a>

Для компиляции Solidity в байт-код zkEVM нужен специальный компилятор. На данный момент поддерживаются `>=0.4.0` версии Solidity, однако все же рекомендуется использовать `^0.8.0` версии как наиболее стабильные. Vyper `^0.3.3` также поддерживается.

Несмотря на то, что более старые версии Solidity поддерживаются, вот некоторые их ограничения на zkSync:

* Рекурсия внутри контракта не поддерживается.
* Указатели внутренних функций не поддерживаются.

Для компиляции смарт-контрактов с помощью Solidity или Vyper, [ознакомьтесь с соответствующими плагинами Hardhat здесь](https://v2-docs.zksync.io/api/hardhat/plugins.html).

Криптографические примитивы Ethereum, такие как `ecrecover`, `keccak256` и `sha256` поддерживаются в виде прекомпилятов (precompiles). От вас не требуется никаких действий, так как все вызовы к предкомпиляциям производятся компилятором под капотом.

### Разница в поведении `CREATE` <a href="#differences-in-create-behaviour" id="differences-in-create-behaviour"></a>

Для простоты поддержки абстракции аккаунта, для каждого аккаунта мы разделяем nonce на две части: _nonce развертывания и nonce транзакции_. Nonce развертывания = количество развернутых контрактов с помощью опкода `CREATE` данным аккаунтом, в то время как nonce транзакции используется для защиты транзакций от атак повторением.

Это означает, что в то время, как для смарт-контрактов nonce на zkSync ведет себя тем же образом, что и на Ethereum, для ЕОА-аккаунтов просчет адреса развернутого контракта не так прямолинеен. На Ethereum, он может быть безопасно просчитан с помощью `hash(RLP[address, nonce])`, в то время как на zkSync рекомендуется дождаться окончания развертывания и "отловить" событие с адресом только что развернутого контракта. Все это происходит на заднем фоне благодаря SDK. Для получения предопределенного адреса стоит использовать `create2`. Он также доступен для ЕОА-аккаунтов, но пока что не доступен в SDK.

### Ремарка о `factory deps` <a href="#note-on-factory-deps" id="note-on-factory-deps"></a>

Под капотом zkSync хранит не байткод контрактов, а [специально форматированные](https://app.gitbook.com/o/7yi2SXsipnanreWF09rl/s/murhp2cgBIKXfRLqThaC/\~/changes/LnFZyzqrINF66IPvOoOE/razrabotka-na-zksync/razvertyvanie-kontrakta#format-of-bytecode-hash) хэши их байткодов. Можно увидеть, что система контракта [ContractDeployer](../../ponimanie-zksync/sistemnye-kontrakty/#contractdeployer) принимает хэш байткода развернутого смарт контракта, а не его байткод. В любом случае, для успешного развертывания контракта, оператор должен знать байткод. По этой причине поле `factory_deps` (т.е. зависимости фабрики) используется для транзакции: оно содержит байткоды, которые должны быть известны оператору для успешного завершения транзакции. Как только транзакция успешно завершается, эти байткоды публикуются на L1 и считаются "известными" оператору навсегда.

Некоторые примеры пользования: Очевидный пример - нужно предоставить код контракта в поле `factory_deps` при развертывании.

* На zkSync, фабрики (т.е. контракты которые могут развертывать другие контракты) не хранят байткод своих зависимостей, т.е. контрактов, которые они могут разворачивать. Они хранят только их хэши. Поэтому вы должны включать _весь_ байткод зависимостей в поле `factory_deps`.

Оба эти примера уже аккуратно реализованы под капотом нашим [плагином hardhat](https://v2-docs.zksync.io/api/hardhat/getting-started.html).

Учтите, зависимости фабрики не обязательно должны фигурировать в транзакции в каком-либо виде. Это просто указатели, что байткод должен быть опубликован на L1 в этой транзакции. Если ваш контракт имеет множество различных зависимостей, и они не помещаются в один блок на L1, вы можете разбить список зависимостей фабрики между несколькими транзакциями.

Например, скажем, вы хотите развернуть контракт `A` который также разворачивает контракты `B` и `C`. Это значит что у вас будет три зависимости фабрики: `A`,`B` и `C`. Если pubdata (публичные данные), требуемые для развертывания всех их, не вмещаются в один блок, то вы можете отправить транзакцию-болванку только с зависимостями `A` и `B` (предполагая что их общая длина достаточно мала) и развернуть контракт следующей транзакцией, передав только байткод `C` как зависимость фабрики. Учтите, что если контракт _сам по себе_ превышает лимит на блок, то контракт должен быть разделен на меньшие по размеру.

#### Коммуникация L1->L2 <a href="#l1-l2-communication" id="l1-l2-communication"></a>

[Интерфейс](https://github.com/matter-labs/v2-testnet-contracts/blob/main/l1/contracts/zksync/interfaces/IMailbox.sol#L78) для отправки L1->L2 транзакций принимает список всех зависимостей фабрики, требуемых для выполнения конкретно этой транзакции. Логика работы с ними сопоставима с логикой работы с L2 транзакциями. Единственное отличие в том, что, поскольку пользователь уже разместил полный праобраз байткодов на L1, нет нужды публиковать эти байткоды L1 повторно.

#### Формат хэша байткодов <a href="#format-of-bytecode-hash" id="format-of-bytecode-hash"></a>

Каждый байткод zkEVM должен соответствовать следующему формату:

* Длина должна быть делима на 32.
* Длина в словах (32-байтных кусках) должна быть нечетной. Другими словами, `bytecodeLength % 64 == 32`.
* Может быть длиннее `2^16` 32-байтных слов, т.е. `2^21` байтов.

32-байтный хэш байткода контракта на zkSync высчитывается следующий образом:

* Первые 2 байта обозначают текущую версию формата хэша байткода, которая на текущий момент равна `[1,0]`.
* Вторые 2 байта обозначают длину байткода в 32-байтных словах.
* Оставшиеся 28 байтов (т.е. 28 байтов низкого порядка) равны последним 28 байтам хэша `sha256` байткода контракта.
