# Перенос средств (бриджинг)

### Введение <a href="#introduction" id="introduction"></a>

Перенос средств реализован через два контракта (один развернут на L1, второй - на L2), коммуницирующих друг с другом через интерфейс [L1 <-> L2 взаимодействия](../interoperabelnost-l1-l2/).Разработчики вольны в создании своих собственных мостов для любых токенов. Однако, мы предоставляем наши мосты по умолчанию (один для ETH и один для токенов ERC20), которые разработчики могут использовать для базового переноса средств.

{% hint style="warning" %}
**ПРЕДУПРЕЖДЕНИЕ**

Адреса токенов на L2 всегда отличаются от их адресов на L1.
{% endhint %}

### Мосты по умолчанию <a href="#default-bridges" id="default-bridges"></a>

Вы можете узнать адреса мостов по умолчанию с помощью конечной точки `zks_getBridgeContracts` или метода `getDefaultBridgeAddresses` `Provider`'a в нашем JS SDK (подобные методы также доступные в других SDK).

#### Депозиты (на L2) <a href="#deposits" id="deposits"></a>

Пользователь должен вызвать метод `deposit` контракта моста на L1, что вызовет следующие действия:

* Токены на L1 отправляются в мост на L1 и блокируются в нем.
* Мост на L1 инициирует транзакцию в пользу моста на L2, используя L1 -> L2 коммуникацию.
* В рамках транзакции на L2 токены минтятся и отправляются на указанный адрес на L2.
  * Если токена еще не существует на zkSync, то для него автоматически развернется новый контракт. Учитывая, что адреса токенов на L1 детерминистические (основываются на оригинальном адресе на L1, названии и тикере), не имеет значения, кто первым сделает перенос токена (бридж), адрес токена на L2 всегда будет одним и тем же.
* Для каждой исполненной L1 -> L2 транзакции всегда будет отправлено лог-сообщение L2 -> L1, подтверждающее ее исполонение.

{% hint style="warning" %}
**ПРЕДУПРЕЖДЕНИЕ**

Если транзакция проваливается по любой из причин (например, оплаченная комиссия слишком низкая), тогда лог-сообщение констатирует ее провал. В этом случае включение лог-сообщения в блок можеть быть доказано на мосту на L1. Это нужно для того, чтобы вернуть депонированные средства назад отправителю путем вызова метода `claimFailedDeposit .`
{% endhint %}

Лог-сообщение, описанное выше полностью не поддерживается нашим SDK в текущем testnet.

#### Выводы (на L1) <a href="#withdrawals" id="withdrawals"></a>

Пользователю нужно вызвать метод `withdraw` контракта моста на L2, что спровоцирует следующие действия:

* Токены на L2 сжигаются
* Отправляется сообщение L2 -> L1 с информацией о том, что вывод отправлен
* После этого кто угодно может завершить вывод на мосту на L1 (доказав включение сообщения L2 -> L1 в блокчейн путем вызова метода `finlizeWithdraw` контракта моста на L1).
* После вызова метода средства на мосту L1 разблокируются и отправляются получателю вывода.&#x20;

{% hint style="warning" %}
В testnet'е мы (Matter Labs) автоматически финализируем все выводы, т.е. мы позаботимся об отправке транзакций на стороне L1, которые будут доказывать включение каждого сообщения в блокчейн.
{% endhint %}
